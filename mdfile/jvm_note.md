#jvm

关键字:  
`HotSpot VM`,`两级即时编译器`, `编译器和解释器混合工作模式`,`模块化`,
`混合语言`,`多核并行``函数式编程`,

-----

##自动内存管理

>jvm 运行时数据区 (JVM栈,本地方法栈,程序计数器,堆,方法区)

- 线程私有
	- Jvm栈 (JVM Stack) 
		- 生命周期与线程相同;
		- 描述的是java方法执行的内存模型:每个方法在执行的同时都会创建一个`栈帧(Stack Frame)`用于存储`局部变量表`,操作数栈,动态链接,方法出口等;
		- `局部变量表` 存放编译期可知的各种基本数据类型(boolean,byte,short,int,long,float,double,char),对象引用(reference类型,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向一条字节码指令的地址);
		- `局部变量表` 64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余数据类型只占用1个;局部变量表所需的内存空间在编译期间完成分配,方法运行期间不会改变局部变量表大小,进入一个方法时,这个方法在栈帧中分配多大的空间已经是确定的;
		- jvm 规定两种异常: 线程请求的栈深度大于虚拟机所允许的深度,抛出`StackOverflowError`异常; 线程扩展时无法申请到足够的内存,抛出`OutOfMemoryError`异常;
		
	- 本地方法栈 (Native Method Stack)
		- 与Jvm栈的区别是Jvm栈为执行java方法服务,此为使用的Native方法服务;
	- 程序计数器 (Program counter Register)
		- 当前线程所执行的字节码的`行号指示器`
		- 线程执行java方法, 计数器记录的是正在执行的虚拟机字节码指令的地址; 线程执行native方法,计数器则为Undefined,
		- 是唯一一个在jvm中没有规定任何OOM情况的区域;


- 线程共享
	- java 堆 (Heap)
		- JVM启动时创建,目的为存放对象实例;
		- GC管理的主要区域,分代收集算法;
		- 线程共享的堆中可划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer);
		- 可以抛出 `OutOfMemoryError`异常;
	- 方法区 (Method Area)
		- 用于存储已被JVM加载的类信息,常量,静态变量,即时编译器编译后的代码等数据;
		- 可以抛出 `OutOfMemoryError` 异常;
		- `运行时常量池`(Runtime Constant Pool) 方法区的一部分,存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放;
			- 具备动态性,不一定是编译期才能产生,也就是并非预置于Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的变量放入池中,利用最多的就是String的`intern()`方法;
		- 可以抛出 `OutOfMemoryError`异常;
	- 直接内存 (Direct Memory)
		- 不是Jvm运行时数据区一部分;可抛出`OutOfMemoryError`异常;
		- Nio(New Input/Output), 引入基于通道Channel和缓冲区Buffer的I/O方式; 可使用native函数库分配堆外内存,通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,避免java堆和native堆中来回复制数据;

----

>对象的创建 (JVM层面的对象创建)

- `new指令 检查`;检查这个指令的参数是否能在常量池中定位一个类的符号引用,检查这个符号引用代表的类是否已被加载,解析,初始化过,如果没有执行类的类加载过程;
- `新生对象分配内存`;对象所需大小在类加载完成后即可完全确定;
	- `指针碰撞`: 分配内存将指针向空闲空间那边挪动一段与对象大小相等的距离;
	- `空闲列表`: jvm维护一个记录可用内存的列表,分配时从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录;
	- 并发情况下的分配内存分两种方案:
		- jvm采用CAS(compare and swap)加上失败重试的方式保证更新操作的原子性;
		- 将内存分配的动作按照线程划分在不同的空间中,每个线程在java堆中预先分配一小块内存,即(Thread Local Allocation Buffer ,TLAB),那个线程需要分配内存,就在那个线程的tlab上分配,只有tlab用完并分配新的tlab时,才需要同步锁定;
- `初始化零值(不包括对象头)`;
- `设置对象头信息`(Object Header); 从jvm角度看一个新的对象已经产生了,但从java程序看,对象创建刚刚开始(<init>方法还没有执行,所有字段都为零,只有new指令之后接着执行<init>方法,真正可用的对象才算完全产生出来;)

-----

>对象的内存布局 (对象头,实例数据,对齐填充)

- 对象头 (Header)
	- 存储对象自身的运行时数据,哈希吗,GC分代年龄,锁状态标志,线程持有的锁,偏向时间戳等,长度为在32位和64位jvm中分别为32bit和64bit;
	- 类型指针,对象指向它的类元数据的指针,jvm通过这个指针确定这个对象是哪个类的实例,非必须;
	- 如果是java数组,还有记录数组长度的数据;
- 实例数据 
	- 对象真正存储的信息;
	- 存储顺序收到虚拟机分配策略参数(fieldsAllocationStyle)和字段在java源码中定义顺序的影响; 默认顺序为 longs/doubles,ints,shorts/chars,bytes/booleans,oops;
- 对齐填充
	- 占位符,hotSpot vm要求对象起始地址必须是8字节的整数倍,对象的大小必须是8字节的整数倍;

-----

> 对象的访问定位

通过jvm栈上的reference数据来操作堆上的具体数据,reference类型 在jvm规范中定义了一个指向对象的引用; 对象访问方式取决于jvm :

- 句柄访问;
	- java堆中划分出一块内存作为句柄池,reference中存储的是对象的句柄地址;句柄中包含了对象实例数据和类型数据的具体地址信息;
	- 优点在于reference存储的是稳点的句柄地址,垃圾回收时只会改变句柄中的实例数据指针,reference本身不需要改变;
		
- 直接指针;
	- java堆对象的布局中放置对象的类型数据,reference存储的直接就是对象地址;
	- 优点在于速度更快,节省一次指针定位的时间开销;

-----

## 垃圾收集器与内存分配策略

程序计数器,jvm栈,本地方法栈都是线程私有的,每一个栈帧中分配多少内存已经在类结构确定下来就已知了,栈中的栈帧随着方法的进入和退出,内存得以回收;而堆内存和方法区不一样,GC主要针对这部分内存;

> 对象已死判定

- 引用计数算法
	- 对象中添加引用计数器,无法解决循环引用问题;

- 可达性分析算法
	- 通过一系列的`GC Roots`对象作为起始点,从这些节点开始向下搜索,搜索走过的路径就是引用链(Reference Chain) ,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的;
	- 可作为GC Roots 的对象包括下面几种:
		- jvm栈(栈帧中的本地变量表) 中引用的对象;
		- 方法区中类静态属性,常量引用的对象;
		- 本地方法栈中jni(native方法)引用的对象;

> 引用分类

- 强引用 StrongReference
	- 类似`var obj = Object()`这类的引用,垃圾回收器永远不会回收掉被引用的对象;
	
- 软引用 SoftReference
	- 有用但非必须对象;
	- 在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中进行第二次回收;

- 弱引用 WeakReference
	- 非必须对象;
	- 只能生存到下一次垃圾收集发生之前,当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被弱引用关联的对象;

- 虚引用 PhantomReference
	- 最弱的引用关系,一个对象是否有虚引用,完全不会对其生存时间构成影响;
	- 无法通过虚引用来取得一个对象实例;
	- 为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知;

> 对象的生存死亡

真正宣告一个对象,至少要经历两次标记过程;

- 对象在经过可达性分析后发现没有与GCRoots相连接的引用链,那它会被第一次标记,并且经过一次筛选,筛选条件为 此对象是否有必要进行`finalize`方法;
	- 当对象没有覆盖finalize方法或finalize已经被jvm调用过,jvm视为没有必要执行,则直接进行GC;
	- 如果jvm视为有必要执行finalize方法,会将此对象放置在一个叫做`F-Queue`队列之中,稍后有一个jvm自动建立的低优先级的Finalizer线程去执行它(触发,不承诺等待它结束);稍后GC将对`F-Queue`中的对象进行第二次小规模的标记,
		- 如果对象在finalize中重新与引用链上的任何一个对象建立关联,那么在第二次标记时移除出"即将回收"的集合;
		- 如果对象在此时还没有建立关联,则被真的回收了;

>方法区的回收

方法区的回收效率较低,主要回收两部分内容: `废弃常量` 和`无用的类`;

判断一个类是无用的类,jvm可以对无用的类进行回收;
	
- 该类的所有实例都已经被回收,java堆中不存在该类实例;
- 加载该类的ClassLoader已经被回收;
- 改类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法;

>垃圾收集算法

- 标记-清除算法 Mark-Sweep
	- 首先标记处所有需要回收的对象,在标记完成后统一回收所有被标记的对象;
	- 不足: 效率低下;清除后空间产生大量不连续的内存碎片;

- 复制算法 Copying
	- 将可用内存划分为容量大小相等的两块,每次只使用其中一块,当着一块用完之后,就将还存活的对象复制到另一块内存上面,然后把已使用的内存空间一次清理掉;
	- 每次都是对整个半区进行回收,运行高效,内存缩小一半代价高;
	- 具体比例分配不需要1:1分配,内存可分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和一块Survivor空间;当回收时,将Eden和Survivor中还存活的对象一次性的复制到另外一块Survivor空间上,最后清理掉Eden和刚才使用的Survivor空间;
	- HotSpot默认Eden和Survivor的比例为8:1,只有10%的内存会被'浪费',当Survivor空间不够用时,需要依赖其他(老年代)内存进行`分配担保`;
		- 内存的分配担保,如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象,这些对象直接通过分配担保进入老年代;

- 标记-整理算法 Mark-Compact
	- 主要针对于老年代,类似于标记清除算法,但后续步骤不是直接对对象进行清理,而是让存活的对象都向一边移动,然后直接清理掉端边界以外的内存;

- 分代收集算法 Generational Collection
	- 根据对象存活周期的不同将内存划分为几块,一般是将java堆分为新生代和老年代,根据各个年代的特点采用最适当的收集算法;
		- 在新生代,每次垃圾回收只有少量存活,选用复制算法;
		- 在老年代,因为对象存活率高,没有额外空间对它进行分配担保,必须使用'标记-清理'或'标记-整理'算法;
