#jvm

关键字:  
`HotSpot VM`,`两级即时编译器`, `编译器和解释器混合工作模式`,`模块化`,
`混合语言`,`多核并行``函数式编程`,

-----

##自动内存管理

>jvm 运行时数据区 (JVM栈,本地方法栈,程序计数器,堆,方法区)

- 线程私有
	- Jvm栈 (JVM Stack) 
		- 生命周期与线程相同;
		- 描述的是java方法执行的内存模型:每个方法在执行的同时都会创建一个`栈帧(Stack Frame)`用于存储`局部变量表`,操作数栈,动态链接,方法出口等;
		- `局部变量表` 存放编译期可知的各种基本数据类型(boolean,byte,short,int,long,float,double,char),对象引用(reference类型,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向一条字节码指令的地址);
		- `局部变量表` 64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余数据类型只占用1个;局部变量表所需的内存空间在编译期间完成分配,方法运行期间不会改变局部变量表大小,进入一个方法时,这个方法在栈帧中分配多大的空间已经是确定的;
		- jvm 规定两种异常: 线程请求的栈深度大于虚拟机所允许的深度,抛出`StackOverflowError`异常; 线程扩展时无法申请到足够的内存,抛出`OutOfMemoryError`异常;
		
	- 本地方法栈 (Native Method Stack)
		- 与Jvm栈的区别是Jvm栈为执行java方法服务,此为使用的Native方法服务;
	- 程序计数器 (Program counter Register)
		- 当前线程所执行的字节码的`行号指示器`
		- 线程执行java方法, 计数器记录的是正在执行的虚拟机字节码指令的地址; 线程执行native方法,计数器则为Undefined,
		- 是唯一一个在jvm中没有规定任何OOM情况的区域;


- 线程共享
	- java 堆 (Heap)
		- JVM启动时创建,目的为存放对象实例;
		- GC管理的主要区域,分代收集算法;
		- 线程共享的堆中可划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer);
		- 可以抛出 `OutOfMemoryError`异常;
	- 方法区 (Method Area)
		- 用于存储已被JVM加载的类信息,常量,静态变量,即时编译器编译后的代码等数据;
		- 可以抛出 `OutOfMemoryError` 异常;
		- `运行时常量池`(Runtime Constant Pool) 方法区的一部分,存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放;
			- 具备动态性,不一定是编译期才能产生,也就是并非预置于Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的变量放入池中,利用最多的就是String的`intern()`方法;
		- 可以抛出 `OutOfMemoryError`异常;
	- 直接内存 (Direct Memory)
		- 不是Jvm运行时数据区一部分;可抛出`OutOfMemoryError`异常;
		- Nio(New Input/Output), 引入基于通道Channel和缓冲区Buffer的I/O方式; 可使用native函数库分配堆外内存,通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,避免java堆和native堆中来回复制数据;

----

>对象的创建 (JVM层面的对象创建)

- `new指令 检查`;检查这个指令的参数是否能在常量池中定位一个类的符号引用,检查这个符号引用代表的类是否已被加载,解析,初始化过,如果没有执行类的类加载过程;
- `新生对象分配内存`;对象所需大小在类加载完成后即可完全确定;
	- `指针碰撞`: 分配内存将指针向空闲空间那边挪动一段与对象大小相等的距离;
	- `空闲列表`: jvm维护一个记录可用内存的列表,分配时从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录;
	- 并发情况下的分配内存分两种方案:
		- jvm采用CAS(compare and swap)加上失败重试的方式保证更新操作的原子性;
		- 将内存分配的动作按照线程划分在不同的空间中,每个线程在java堆中预先分配一小块内存,即(Thread Local Allocation Buffer ,TLAB),那个线程需要分配内存,就在那个线程的tlab上分配,只有tlab用完并分配新的tlab时,才需要同步锁定;
- `初始化零值(不包括对象头)`;
- `设置对象头信息`(Object Header); 从jvm角度看一个新的对象已经产生了,但从java程序看,对象创建刚刚开始(<init>方法还没有执行,所有字段都为零,只有new指令之后接着执行<init>方法,真正可用的对象才算完全产生出来;)

-----

>对象的内存布局 (对象头,实例数据,对齐填充)

- 对象头 (Header)
	- 存储对象自身的运行时数据,哈希吗,GC分代年龄,锁状态标志,线程持有的锁,偏向时间戳等,长度为在32位和64位jvm中分别为32bit和64bit;
	- 类型指针,对象指向它的类元数据的指针,jvm通过这个指针确定这个对象是哪个类的实例,非必须;
	- 如果是java数组,还有记录数组长度的数据;
- 实例数据 
	- 对象真正存储的信息;
	- 存储顺序收到虚拟机分配策略参数(fieldsAllocationStyle)和字段在java源码中定义顺序的影响; 默认顺序为 longs/doubles,ints,shorts/chars,bytes/booleans,oops;
- 对齐填充
	- 占位符,hotSpot vm要求对象起始地址必须是8字节的整数倍,对象的大小必须是8字节的整数倍;

-----

> 对象的访问定位

通过jvm栈上的reference数据来操作堆上的具体数据,reference类型 在jvm规范中定义了一个指向对象的引用; 对象访问方式取决于jvm :

- 句柄访问;
	- java堆中划分出一块内存作为句柄池,reference中存储的是对象的句柄地址;句柄中包含了对象实例数据和类型数据的具体地址信息;
	- 优点在于reference存储的是稳点的句柄地址,垃圾回收时只会改变句柄中的实例数据指针,reference本身不需要改变;
		
- 直接指针;
	- java堆对象的布局中放置对象的类型数据,reference存储的直接就是对象地址;
	- 优点在于速度更快,节省一次指针定位的时间开销;

-----

## 垃圾收集器与内存分配策略

程序计数器,jvm栈,本地方法栈都是线程私有的,每一个栈帧中分配多少内存已经在类结构确定下来就已知了,栈中的栈帧随着方法的进入和退出,内存得以回收;而堆内存和方法区不一样,GC主要针对这部分内存;

> 对象已死


