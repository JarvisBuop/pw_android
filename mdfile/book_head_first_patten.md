#HeadFirst

---

> OO 基础

- 抽象
- 封装 
- 多态
- 继承

> OO设计原则(单一职责,开闭,里氏替换,依赖倒置,接口隔离,迪米特(最小知识),组合复用)

- 封装变化 (单一职责原则)
	- 将变化的部分抽象出来,封装成单独的类;
	- `策略模式` (定义算法族,分别封装,之间可以相互`替换`,用于封装变化)
 
- 针对接口编程,不针对实现编程 (依赖倒置原则,里氏替换原则)
	- 面向接口或者抽象类,而不是面对具体实现;

- 多用组合,少用继承 (组合复用原则, `has a` > `is a`)
	- 使用继承,在子类很多的时候,需要重写一堆方法; 而如果使用接口来表示功能类时,会产生代码不能重用的问题; 
	- 使用组合,可以将功能抽象成单独的算法族,一个抽象类和多个实现类可以灵活的实现功能,且可以重用代码;

- 为了交互对象之间的松耦合而努力 (最少知识原则)
	- 改变关联对象中的其中一方,并不会影响另一方; 接口的规则满足即可;
	- `观察者模式` (定义对象间的`一对多`依赖,用于`松耦合`,一个对象改变状态,所有依赖着都会收到通知且自动更新)

- 开闭原则 
	- 类应该对修改关闭,对扩展开放;
	- `装饰者模式` (动态将责任附加到对象上,用于`扩展`功能,可替代继承;)
		- 装饰和被装饰者有相同的超类,进行类型匹配,而不是行为;
		- 一个或多个装饰者包装被装饰者;
		- 装饰者可以在被装饰者行为之前后之后,加上自己的行为;
		- 可以添加两层抽象;
	- 装饰者模式可有效使用工厂模式和构造器模式;

- 依赖倒置原则 (要依赖`抽象`,不依赖具体类,高层组件和低层组件都要依赖抽象)
	- B -> A <- a1,a2,a3 
	- `工厂方法模式` (定义创建对象的接,由`子类决定实例化`的类,工厂方法把实例化推迟到子类)
	- `抽象工厂模式` (提供一个接口,用于`创建相关或依赖对象的家族`,不需要明确指定具体类)

- `单例模式` (确保一个类只有`一个实例`,提供一个全局访问点)
	
- `命令模式` (`封装方法调用`,将请求封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象;)
	- AbstractCommands (execute + undo) + CommandInvoker + ActionReceiver 
	- 命令队列请求; (线程池取出命令对象执行execute)
	- 日志请求; (checkpoint + store() + load()+ Serialization Persistence)

- 最少知识原则 (减少对象间的交互,只和朋友交谈)
	- `适配器模式` (`转换接口类型`,将接口不兼容的类转换为需要的接口)
		- 包装其他类输出需要的接口,侧重于转换接口;
		- 对象适配器 | 类适配器
	
	- `外观模式` (`简化接口`, 提供一个统一的接口,用来访问子系统的一群接口)
		- 包装其他类输出需要的接口,侧重于简化接口;
	- 就任何对象而言,在该对象的方法内,只应该调用属于以下范围的方法:
		- 该对象本身;
		- 被当做方法的参数而传递进来的对象;
		- 此方法所创建或实例化的任何对象;(上述说明,如果某对象是调用其他的方法的返回结果,不要调用该对象的方法;违反最少知识原则)
		- 对象的任何组件;(has a)

- `模板模式` (`封装算法` ,定义一个算法的骨架,子类可以不改变算法结构的情况下,重新定义算法中的某些步骤;)
	- `hook`方法,按需复写方法,常用于可选部分,相对于必须复写的`abstract`;
	
- 好莱坞原则 (WTF!! 高层组件对待低层组件方式: 别调用我们,我们会调用你;)
	- 防止依赖腐败
	- 理解为`多态`即可;
	
- 单一职责原则 (一个类应该只有一个引起变化的原因)
	- `迭代器模式` (`遍历集合隐藏实现`, 提供方法顺序访问一个聚合对象中的元素,而不暴露其内部的实现;)
	- 线性一维 ->迭代器模式;
	

- `组合模式` (将对象组合成树状结构来表现 `整体/部分` 层次结构,以一致的方式处理个别对象以及对象组合;) 
	- 树状多维 -> 组合模式;
	- 组合(composite) - 组件(component,共同接口) - 叶子(leaf)
		- 组合包含组件,组件有组合节点和叶子节点
	- 透明性: 通过让组件的接口同时包含一些管理子节点和叶节点的操作,可使组合和叶节点一视同仁;
	- `组合迭代器`: 维护组合递归结构位置,使用`堆栈Stack`,达到树状结构的顺序遍历;

- `状态模式` (允许对象在`内部状态`改变时改变它的行为)
	- 步骤
		- 定义State接口,声明action方法;
		- 为每个状态创建状态类,重写action方法;
		- 将动作委托给状态类;
	- 与策略的差异:
		- 通常策略是继承的一种弹性替代方案,通过组合不同的对象改变行为;
		- 状态可以是context条件判断的替代方案;

- `代理模式` (`控制和管理访问`,为另一个对象提供一个替身或占位符以控制对这个对象的访问;)
	- RMI (jdk 提供远程访问工具) 
		- 客户对象-客户辅助对象 -- 服务辅助对象 - 服务对象;
		- 客户辅助对象(Stub)
		- 服务辅助对象(Skeleton)
		- rmic工具
	- 远程代理
	- 虚拟代理
	- 缓存代理
	- `保护代理`
		- 动态代理,控制对象的访问,在运行时才会创建代理类;
		- Proxy.newProxyInstance()
		- InvocationHandler: 代理方法被调用时,代理就会把这个调用转发给InvocationHandler;
			
	
- `桥接模式` (将`实现和抽象`放在不同的维度,可以独立改变)
	- 抽象维度 has a 实现维度;

- `构建者模式` (`链式`builder)


- `责任链模式` (`对象链`,多个对象处理一个请求)
	- 纯责任链模式 && 非纯责任链模式 (是否请求被一个责任链处理者处理)

- `享元模式` (`池`,重用实例)

- `解释器模式` (每一个语法规则表示成一个类,`类直接映射到语法`)
	- 计算器

- `中介者模式` (`对象间关系由中介者沟通`,集中相关对象之间复杂的沟通和控制方式)
	- 电脑与外设

- `备忘录模式` (`存储关键状态`,让对象返回之前的状态)

- `原型模式` (`深拷贝和浅拷贝`,通过复制现有的实例创建新的实例,clone方法 or 反序列化)

- `访问者模式` (`定义对每个元素的访问行为`,为一个对象的组合增加新的能力,且封装并不重要)
	- 每个元素提供一个accept方法,用于将自身回调出去给访问者;
	- 访问者当做参数传入accept中;


-----
 
	